---
aliases:
  - python
tags:
  - python基础
  - 学习笔记
---

# 1. Python 基础语法体系 (Basic Syntax)

## 1. 运行环境 (Environment)。
>容易搞混（

| 环境名称      | 英文名称             | 标志符号            | 用途          | 避坑指南                                         |
| :-------- | :--------------- | :-------------- | :---------- | :------------------------------------------- |
| **系统终端**  | Shell / Terminal | `PS C:\>` 或 `$` | 运行 `.py` 文件 | 在这里输入 `python 文件名.py` 启动程序。                  |
| **交互式环境** | REPL             | `>>>`           | 测试单行代码      | **严禁**在此输入系统指令（如 `python`），会报 `SyntaxError`。 |


## 2. 基础逻辑 (Basic Logic)
- **文件后缀**：Python 源代码文件的标准后缀是 `.py`。
- **缩进 (Indentation)**：Python 使用缩进（强制为 **4个空格**）来界定代码块的逻辑层级，代替了其他语言中的大括号 `{}`。
- **动态类型 (Dynamic Typing)**：创建变量时**不需要**声明数据类型，解释器会自动推断。

## 3. 交互逻辑 (Input & Output)

### 输出函数 `print()`
- **功能**：将信息打印到控制台。
- **格式示例**：
	1. `print(variable)`：直接打印变量。
	2. `print("Text")`：打印纯文本。
	3. `print(f"Text {variable}")`：**f-string** 格式化输出（推荐）。

### 输入函数 `input()`
- **功能**：获取用户在键盘上的输入。
- **格式示例**：
	- `variable = input("Prompt Text")`
- **⚠️ 核心注意**：`input()` 接收到的数据默认永远是 **字符串 (String)** 类型。

---

# 2. 变量与数据类型 (Variables & Types)

## 1. 基础数据类型

| 类型 (Type)   | 代码简写    | 说明       | 示例                   |
| :---------- | :------ | :------- | :------------------- |
| **Integer** | `int`   | 整数       | `age = 18`           |
| **Float**   | `float` | 浮点数（小数）  | `height = 1.76`      |
| **String**  | `str`   | 字符串（文本）  | `device = "Lenovo"`  |
| **Boolean** | `bool`  | 布尔值（真/假） | `is_student = False` |

## 2. 类型转换 (Type Casting)
**核心坑点**：若不进行转换直接对 `input()` 的结果做数学运算，程序会抛出 `TypeError`。

- **常用转换函数**：
    - `int(v)`：转为整数（截断小数，或将整数字符串转数字）。
    - `float(v)`：转为浮点数（例如 `"1.76"` -> `1.76`）。
    - `str(v)`：转为字符串（例如 `100` -> `"100"`）。
## 3. 字符串常用方法

|**方法**|**语法**|**说明**|**示例**|
|---|---|---|---|
|**去空格**|`s.strip()`|去除字符串**首尾**的空格或换行符。|`" Alex ".strip()` -> `"Alex"`|
|**转小写**|`s.lower()`|将所有字母转为小写（常用于忽略大小写判断）。|`"EXIT".lower()` -> `"exit"`|
|**转大写**|`s.upper()`|将所有字母转为大写。|`"vip".upper()` -> `"VIP"`|
|**分割**|`s.split(sep)`|按指定符号切割，**返回列表**。|`"A,B,C".split(",")` -> `['A', 'B', 'C']`|
|**开头判断**|`s.startswith(x)`|判断是否以 x 开头 (返回 Bool)。|`"2025-01".startswith("2025")`|

---

# 3. 运算符 (Operators)

### 1. 赋值运算符 (Assignment Operators)
- `=`：**赋值**。将右边的值赋给左边的变量（注意：这不是“等于”）。
  - 示例：`score = 90`

### 2. 数学运算符 (Arithmetic Operators)
- `+` (加), `-` (减), `*` (乘), `/` (除，结果为浮点数)
- `//` (**整除**，向下取整), `%` (**取模**，求余数), `**` (**幂运算**，次方)

### 3. 比较运算符 (Comparison Operators)
在让程序做决定之前，需要先进行“比较”。结果只有 `True` 或 `False`。

| 运算符 | 描述 (Description) | 示例 |
| :--- | :--- | :--- |
| `==` | **等于** (Equal) | `5 == 5` -> `True` |
| `!=` | **不等于** (Not equal) | `5 != 3` -> `True` |
| `>` | 大于 | `5 > 3` -> `True` |
| `<` | 小于 | `2 < 1` -> `False` |
| `>=` | 大于或等于 | `5 >= 5` -> `True` |
| `<=` | 小于或等于 | `4 <= 3` -> `False` |

### 4. 逻辑运算符 (Logical Operators)
用于组合多个布尔条件：
- **`and`** (且)：**全真则真**。左右都为 True，结果才为 True。
- **`or`** (或)：**一真则真**。左右只要有一个 True，结果就为 True。
- **`not`** (非)：**取反**。`True` 变 `False`。

---

# 4. 流程控制 (Control Flow)

## 1. 条件判断语句 (Conditional Statements)
### `if-elif-else` 结构
- **核心语法**：注意行末的冒号 `:` 和下一行的缩进。
- **逻辑**：程序自上而下匹配，执行第一个为 `True` 的分支，然后跳出整块判断。

```python
age_str = input("请输入你的年龄: ")
try:
    age = int(age_str)
    if age >= 18:
        print("已成年")
    elif age >= 12:
        print("青少年")
    else:
        print("未成年")
except ValueError:
    print("请输入数字")
```
## 2. 循环结构 (Loops)

### `while` 循环 (条件循环)

- **适用场景**：不知道循环多少次，只知道“当满足某条件时”持续执行。
    
- **语法结构**：
    


```python
while 条件表达式:
    # 循环体
    # 务必包含改变条件的语句，否则死循环
```

### `for` 循环 (遍历循环)

- **适用场景**：已知循环次数，或遍历序列。
    
- **语法结构**:
    
```python
for 变量 in 可迭代对象:
    # 循环体
```

- **Range 函数**: `range(start, stop, step)`
    
| 参数        | 含义  | 特点                 |
| --------- | --- | ------------------ |
| **start** | 起始值 | 默认为 0，包含该值。        |
| **stop**  | 终止值 | **不包含该值**（左闭右开区间）。 |
| **step**  | 步长  | 默认为 1。             |
- **enumerate()**:带索引遍历
既想要元素，又想要它的排名（索引）时使用。
```python
names = ["Alice", "Bob", "Charlie"]
# i 是索引，name 是元素
for i, name in enumerate(names):
    print(f"第 {i+1} 名是: {name}")
```


- **zip()**:并行遍历
```python 
names = ["Alice", "Bob"]
scores = [90, 85]
for n, s in zip(names, scores):
    print(f"{n} 考了 {s} 分")
```


#### 列表推导式（List Comprehensions）
能够将三行的循环代码压缩成一行，且运行速度更快。
- **基础语法**:`[expression for item in iterable if condition]`
- **对比示例**：

**传统写法**：
```python
squares = []
for x in range(10)
	if x % 2 == 0:
		squares.append(x**2)
```

**推导式写法**：
```python
squares =[x**2 for x in range(10) if x % 2 == 0]
```

### 循环控制关键字

- **`break`**：**终止**。彻底跳出整个循环。
    
- **`continue`**：**跳过**。跳过本次循环剩余代码，直接开始下一轮。
    

## 3. 异常处理 (Error Handling)

用于“防御性编程”，防止程序因意外错误（如用户输入乱码）而崩溃。


```python
try:
    # 放置可能报错的“高风险”代码
    num = float(input("请输入数字: "))
except ValueError:
    # 专门捕获数值转换错误
    print("格式错误：请输入纯数字！")
except Exception as e:
    # 捕获其他所有未知错误
    print(f"未知错误：{e}")
finally:
    # (可选) 无论是否报错都会执行，常用于资源清理
    pass
```

---
# 5. 数据结构（Data Structures）
## 1.列表（List）

### 核心概念

- 定义：列表是一个有序、可变的容器，可以同时存放多个数据。

- 语法：使用方括号`[]`包裹，元素之间用逗号`,`隔开

### 基础操作

| **操作** | **语法 / 函数**   | **说明**                    | **示例**                  |
| ------ | ------------- | ------------------------- | ----------------------- |
| **创建** | `name = []`   | 创建空列表或带值列表                | `scores = [90, 80, 95]` |
| **追加** | `.append(元素)` | **最常用**。在列表**末尾**添加一个新元素。 | `scores.append(100)`    |
| **读取** | `列表[索引]`      | 索引从 **0** 开始。             | `scores[0]` (获取第1个)     |
| **计数** | `len(列表)`     | 获取列表里有多少个元素。              | `len(scores)` -> 3      |
| **求和** | `sum(列表)`     | **数学特技**。计算所有数字的总和。       | `sum(scores)` -> 265    |

### 进阶操作

| **操作**      | **语法**                    | **说明**                         |
| ----------- | ------------------------- | ------------------------------ |
| **修改**      | `list[i] = new_val`       | 直接覆盖指定位置的数据。                   |
| **删除 (撤销)** | `list.pop()`              | 移除并返回列表的**最后一个**元素 (常用于 Undo)。 |
| **删除 (指定)** | `list.remove(x)`          | 移除列表中第一个值为 `x` 的元素。            |
| **排序**      | `list.sort()`             | 升序排列 (从小到大)。                   |
| **倒序**      | `list.sort(reverse=True)` | 降序排列 (从大到小)。                   |

## 2. 字典 (Dictionary)

字典是一种存储 **键值对 (Key-Value Pairs)** 的无序容器（Python 3.7+ 保持插入顺序）。

### 核心特性

- **映射关系**：通过唯一的 **键 (Key)** 找到对应的 **值 (Value)**。
    
- **查找效率**：极高，不会随数据量增大而变慢。

### 基础操作 (CRUD)

| **操作**    | **语法**                             | **说明**                  |
| --------- | ---------------------------------- | ----------------------- |
| **创建**    | `d = {"name": "Astra", "age": 18}` | 使用 `{}` 和 `:`。          |
| **查询**    | `value = d["key"]`                 | 若 Key 不存在会报 `KeyError`。 |
| **安全查询**  | `d.get("key", default)`            | 若 Key 不存在则返回默认值，不报错。    |
| **修改/新增** | `d["key"] = new_value`             | Key 存在则覆盖，不存在则新建。       |
| **删除**    | `del d["key"]`                     | 移除指定的键值对。               |
### 字典的常用内置方法 (Common Methods)

除了基础的增删改查，字典还有几个极其高频的方法，用于批量处理数据。

| **方法**          | **语法**                   | **说明 (Description)**            |
| --------------- | ------------------------ | ------------------------------- |
| **`.keys()`**   | `d.keys()`               | 获取字典中**所有的键**（返回类似列表的结构）。       |
| **`.values()`** | `d.values()`             | 获取字典中**所有的值**。                  |
| **`.items()`**  | `d.items()`              | **最常用**。同时获取键和值（用于循环遍历）。        |
| **`.update()`** | `d.update(d2)`           | 合并字典。用 `d2` 的内容更新 `d`，重复的键会被覆盖。 |
| **`.clear()`**  | `d.clear()`              | 清空字典内所有内容。                      |
| **`.items()`**  | `for k, v in d.items():` | **遍历神器**。同时获取键（科目）和值（分数）。       |
| **`.get()`**    | `d.get("Math", 0)`       | **安全获取**。如果科目不存在，返回 0 而不是报错。    |
## 3. 列表切片 (List Slicing)
切片用于从序列中提取子集。语法同样适用于字符串 (String) 和元组 (Tuple)。

### 核心语法 (Syntax)
$$list[start : stop : step]$$

* **法则**：**左闭右开**。即包含 $start$ 索引，但不包含 $stop$ 索引：$[start, stop)$。

| 切片方式 | 示例 | 说明 |
| :--- | :--- | :--- |
| **基础区间** | `list[1:4]` | 获取索引 1, 2, 3 的元素。 |
| **省略开头** | `list[:3]` | 从头开始取，直到索引 2。 |
| **省略结尾** | `list[2:]` | 从索引 2 开始取到最后。 |
| **负数索引** | `list[-2:]` | 获取最后两个元素（倒数第二到末尾）。 |
| **反转列表** | `list[::-1]` | 快速反转整个列表顺序。 |



## 4. 组合数据结构：列表嵌套字典 (Nesting)
这是存储结构化数据（如班级名册）的标准方式。

- **结构**：一个 **列表 (List)** 里面装了多个 **字典 (Dictionary)**。
- **示例**：
```python
students = [
    {"name": "Steve", "score": 95.0},
    {"name": "Alex", "score": 88.5}
]
# 访问第一个学生的名字：students[0]["name"]
```

## 5.元组 (Tuple)
“不可变”的列表，数据的保险箱。

### 核心特性
- **不可变 (Immutable)**：一旦创建，不能修改、新增或删除元素。
- **语法**：使用圆括号 `()`。
    - **特例**：单元素元组必须加逗号，如 `(1,)`，否则会被视为数学运算括号。

### 常用操作
| 操作 | 语法 | 说明 |
| :--- | :--- | :--- |
| **查询** | `t[0]` | 通过索引访问。 |
| **拆包** | `x, y = point` | 将元组元素一次性赋值给多个变量（如坐标点）。 |
| **应用** | `config = ("192.168.1.1", 80)` | 适用于存储不希望被篡改的配置数据。 |

## 6.集合 (Set) - 去重的“筛子” (可选)

既然补全了元组，顺便提一下 **集合 (Set)**，它的出场率稍低，但功能极其独特。

- **语法**：`s = {1, 2, 3}` (和字典一样用花括号，但没有冒号)。
    
- **特性**：
    
    1. **无序**：没有索引，不能用 `s[0]` 访问。
        
    2. **不重复**：自动去重。如果你把 `[1, 1, 2]` 丢给集合，它只保留 `{1, 2}`



---
# 6. 函数 (Functions)
## 1.定义与调用
- **关键字**：使用`def`定义，使用`return`返回结果。
- **命名**：蛇形命名法。
## 2.参数（Arguments）
- 函数可以接受零个或者多个参数。
- 参数是函数内部的局部变量，外部无法访问。
- 函数的“默认参数陷阱”:  **可变默认参数** **永远不要**使用可变对象（如 `[]` 或 `{}`）作为函数的默认参数。
	- **错误写法**：
    ```python
    def add_item(item, box=[]): # ❌ 危险！所有调用者共用同一个 box
        box.append(item)
        return box
    ```
	- **正确写法**：
    ```python
    def add_item(item, box=None): # ✅以此为标准
        if box is None:
            box = [] # 在函数内部新建
        box.append(item)
        return box
    ```
## 3.返回值（Return）
- `return`会结束函数的执行。
- 如果没有写`return`，函数会默认返回`None`。
- 可以返回多个值，接收时使用拆包语法：`a, b = my_func()`。
## 4.函数的作用域 (Scope)

- **局部变量 (Local Variable)**：在函数内部定义的变量（如你函数里的 `tmp_student`）。它只在函数运行时存在，运行结束就消失了。
    
- **返回值 (Return)**：它是局部变量通往外部世界的“唯一桥梁”。
    
- **参数 (Arguments)**：它是外部数据进入函数的“专用通道”。
    

** 黄金法则**：尽量在函数内部处理数据，通过 `return` 把结果交出来，而不是去修改函数外部的变量。


# 7. 文件操作与持久化 (Persistence)

### 1. 基础读写

- 使用 `with open(路径, 模式, encoding="utf-8") as f` 以确保安全关闭。
    
- **模式**：`r`(读), `w`(覆盖写), `a`(追加写)。
    

### 2. JSON 处理 (数据存档)

- **模块**：`import json`。
    
- **序列化 (Serialization)**：`json.dump(obj, f)` —— 将对象存入文件。
    
- **反序列化 (Deserialization)**：`json.load(f)` —— 将文件内容读回对象。
    
- **优势**：完美保留列表、字典的嵌套结构。

## 3. 对象的持久化 (Serialization)

> **💡 核心矛盾**：JSON 只能识别基础数据（字典、列表），无法直接识别你定义的 `Student` 类对象。

### 1. 序列化 (Serialization)

- **定义**：把“活”的对象拆解为“死”的字典。
    
- **实现**：在类中定义 `to_dict(self)` 方法。
    

```python
def to_dict(self):
    return {
        "name": self.name,
        "grades": self.grades
    }
```

#### 2. 反序列化 (Deserialization)

- **定义**：根据读到的字典数据，重新“组装”并“复活”出一个对象。
    
- **实现**：使用 `@classmethod` 装饰器定义工厂方法。
    


```python
@classmethod
def from_dict(cls, data):
    # data 是从 json 加载的字典
    return cls(data["name"], data["grades"])
```

### 4. OS 路径管理 (Path Management)

> **注意**：在 Windows 上路径用 `\`，在 Mac/Linux 上用 `/`。如果你在代码里写死 `data\file.json`，换个系统程序就挂了。使用 `os` 模块可以自动处理这些差异。

#### 1. 核心导航函数 (os.path)

需先导入模块：`import os`

|**函数**|**语法**|**说明**|**示例 (Windows环境)**|
|---|---|---|---|
|**智能拼接**|`os.path.join(a, b)`|**最重要**。自动根据系统补充斜杠。|`join("data", "file.txt")` -> `"data\file.txt"`|
|**绝对路径**|`os.path.abspath(path)`|获取文件的完整“门牌号”。|`abspath("main.py")` -> `"C:\Users\Admin\Project\main.py"`|
|**父级目录**|`os.path.dirname(path)`|返回当前路径的**上一层**文件夹。|`dirname("C:\A\B")` -> `"C:\A"`|
|**是否存在**|`os.path.exists(path)`|判断文件或文件夹是否真实存在 (返回 Bool)。|`if not exists(file): return`|

#### 2. 文件夹管理

- 自动创建文件夹：
    
    防止保存文件时因为文件夹不存在而报错。
    
    Python
    
    ```
    # exist_ok=True 表示：如果文件夹已经存在，不要报错，继续运行即可
    os.makedirs("data/backup", exist_ok=True)
    ```
    

#### 3. 实战：动态锁定项目根目录 (Project Anchor)

- **`__file__`**：Python 的内置变量，代表**当前代码文件自己**。
    

**标准模板代码**：

```python
import os

# 1. 锁定当前脚本的位置 (比如 json_handler.py)
current_path = os.path.abspath(__file__)

# 2. 爬楼梯：获取当前脚本所在的目录
current_dir = os.path.dirname(current_path)

# 3. 再爬一层：获取项目根目录 (假设 handler 在子文件夹 core 里)
# 如果 handler 就在根目录，这一步可以省略
base_dir = os.path.dirname(current_dir)

# 4. 拼接数据文件路径
# 结果：C:\Project\VMS\data\inventory.json
data_file = os.path.join(base_dir, "data", "inventory.json")

print(f"数据库锁定路径: {data_file}")
```
---
# 8. 面向对象编程（OOP）
这是 Python 从“写脚本”进阶到“写系统”的核心思维。
## 1. 核心概念
- **类(class)**：相当于一个图纸或者模板。定义了对象有什么属性和方法。
- **对象(Object)**：根据图纸造出来的具体事物（实例）。
- **实例化**：`s = Student`,造对象的过程。
## 2. 基础语法架构

```python
class Student:
    # 1. 构造方法 (初始化)
    # self 代表“当前被创建的这个对象”
    def __init__(self, name, score):
        self.name = name    # 属性：写进对象的档案里
        self.score = score

    # 2. 实例方法 (技能)
    def check_pass(self):
        if self.score >= 60:
            return True
        return False
```

## 3. 类的访问控制(Access Contrl)

python通过**下划线命名**来约定权限。

| **写法**     | **名称**         | **含义**                    | **实际效果**                                                    |
| ---------- | -------------- | ------------------------- | ----------------------------------------------------------- |
| `func`     | 公有(Public)     | 所有人可以随意使用。                | 无限制                                                         |
| `_func`    | 受保护(Protected) | **君子协定**。暗示这是内部使用的。外部最好别碰 | 1.依然可以强行访问 <br>2. `from m import`无法导入。                      |
| `__func`   | 私有(Private)    | **以此为界**。意图完全隐藏。防止子类名称冲突。 | 触发名称改写(python会给这个函数名前自动加上类名，例如：`_Student__func`),外部直接访问会报错。 |
| `__func__` | 魔术方法           | 系统内置功能                    |                                                             |

代码示例:

```python
class Account:
    def __init__(self, balance):
        self.owner = "Alex"      # 公有：随便看
        self._type = "VIP"       # 受保护：建议别改，但能改
        self.__balance = balance # 私有：拒绝访问

    def get_balance(self):
        return self.__balance    # 类自己内部可以访问私有属性

acc = Account(1000)
print(acc.owner)       # ✅ Alex
print(acc._type)       # ⚠️ 能运行，但不规范
# print(acc.__balance) # ❌ 报错！外部无法访问
```

## 3. 关键术语表
| **术语**| **说明**| **通俗理解**|
| ------------------ | ----------- | ---------------------------|
| **`class`**| 定义类的关键字。    | “我要画一张图纸”。                  |
| **`self`**| 实例自身的引用。    | “我自己”。`self.name` = “我的名字”。 |
| **`__init__`** | 初始化魔术方法。    | “出厂设置”。                     |
| **属性 (Attribute)**| `self.变量名`。| 对象的“特征”（如血量、名字）。            |
| **方法 (Method)**  | 类里面的函数。  | 对象的“技能”（如攻击、存盘）。            |
## 4. 魔术方法(Magic Methods)

### 1. 魔术方法的本质

魔术方法是 Python 的**钩子（Hooks）**机制。

- **触发机制**：你永远不需要直接写 `obj.__add__(1)`。
	
- **使用方式**：你只需要写 `obj + 1`，Python 解释器会自动在后台寻找并调用 `__add__`。

---

### 2. 初始化与生命周期 (Life Cycle)

这些方法决定了一个对象是如何诞生和消亡的。

| **方法名**                   | **触发时机**             | **核心作用**                                                     |
| ------------------------- | -------------------- | ------------------------------------------------------------ |
| **`__new__(cls, ...)`**   | `Instance = Class()` | **构造器**。真正的创建实例，比 `__init__` 更早执行。通常用于单例模式或继承不可变类型（如 tuple）。 |
| **`__init__(self, ...)`** | `Instance = Class()` | **初始化器**。对象创建后，给它赋予初始属性。**最常用**。                             |
| **`__del__(self)`**       | `del obj` 或程序结束      | **析构器**。对象被垃圾回收时触发。但在 Python 中很难精准控制其触发时间，**尽量少用**。          |

---

### 3. 字符串表示 (Representation)

决定对象打印出来的样子。

| **方法名**              | **触发时机**                 | **核心作用**                   | **区别**                                 |
| -------------------- | ------------------------ | -------------------------- | -------------------------------------- |
| **`__str__(self)`**  | `print(obj)`, `str(obj)` | **面向用户**。返回可读性强、排版美观的字符串。  | 侧重“好看”。                                |
| **`__repr__(self)`** | 交互式终端直接回车, `repr(obj)`   | **面向开发**。返回无歧义的、包含类信息的字符串。 | 侧重“准确”。理想情况下 `eval(repr(obj)) == obj`。 |

**通用模版**：


```python
def __repr__(self):
    return f"{self.__class__.__name__}(id={self.id})"
```

---

### 4. 比较运算 (Comparison)

让对象支持逻辑判断。

| **运算符** | **对应方法**                  | **逻辑含义**                          |
| ------- | ------------------------- | --------------------------------- |
| `==`    | **`__eq__(self, other)`** | 相等 (Equal)                        |
| `!=`    | **`__ne__(self, other)`** | 不等 (Not Equal)                    |
| `<`     | **`__lt__(self, other)`** | 小于 (Less Than) - **排序(`sort`)必备** |
| `>`     | **`__gt__(self, other)`** | 大于 (Greater Than)                 |
| `<=`    | **`__le__(self, other)`** | 小于等于                              |
| `>=`    | **`__ge__(self, other)`** | 大于等于                              |

> **注意**：如果不实现 `__eq__`，Python 默认比较内存地址（`id`）。

---

### 5. 算术运算 (Arithmetic)

让对象支持数学计算。

|**运算符**|**对应方法**|**说明**|
|---|---|---|
|`+`|**`__add__(self, other)`**|加法|
|`-`|**`__sub__(self, other)`**|减法|
|`*`|**`__mul__(self, other)`**|乘法|
|`/`|**`__truediv__(self, other)`**|真除法 (结果含小数)|
|`//`|**`__floordiv__(self, other)`**|地板除 (取整)|
|`%`|**`__mod__(self, other)`**|取模 (余数)|
|`**`|**`__pow__(self, other)`**|幂运算|

> **进阶**：还有 **`__iadd__`** (对应 `+=`) 和 **`__radd__`** (反向加法，当左操作数不支持加法时触发)。

---

### 6. 容器与序列 (Container & Sequence)

让对象像列表（List）或字典（Dict）一样工作。

|**方法名**|**触发时机**|**核心作用**|
|---|---|---|
|**`__len__(self)`**|`len(obj)`|返回容器内元素的数量。|
|**`__getitem__(self, key)`**|`obj[key]`|**获取**指定键/索引的值。|
|**`__setitem__(self, key, val)`**|`obj[key] = val`|**修改/新增**指定键的值。|
|**`__delitem__(self, key)`**|`del obj[key]`|**删除**指定元素。|
|**`__contains__(self, item)`**|`item in obj`|自定义 `in` 关键字的判断逻辑。|
|**`__iter__(self)`**|`for x in obj`|返回一个迭代器，让对象可被遍历。|

---

### 7. 可调用对象 (Callable)

让对象伪装成函数。

- **方法**：**`__call__(self, ...)`**
    
- **触发**：`instance()`
    
- **用途**：当一个对象需要保持状态（属性），但又经常被像函数一样执行时使用。
    


```python
class Adder:
    def __init__(self, n):
        self.n = n
    
    def __call__(self, x):
        return self.n + x

plus_10 = Adder(10) # 创建对象
print(plus_10(5))   # 像函数一样调用对象 -> 输出 15
```

---

### 8. 上下文管理 (Context Manager)

配合 `with` 语句使用，常用于资源管理（文件、网络连接）。

|**方法名**|**触发时机**|**核心作用**|
|---|---|---|
|**`__enter__(self)`**|`with obj:`|进入代码块前执行（如：打开文件）。返回的对象会给到 `as` 后的变量。|
|**`__exit__(self, ...)`**|退出代码块时|离开代码块后执行（如：关闭文件）。**即使报错也会执行**，用于异常处理。|

---

### 9. 属性控制 (Attribute Access) - ⚠️ 高危区

拦截对属性的访问（`.`操作符）。

|**方法名**|**触发时机**|**用途**|**警告**|
|---|---|---|---|
|**`__getattr__(self, name)`**|访问**不存在**的属性时|动态处理未定义的属性调用。|只有找不到时才触发。|
|**`__setattr__(self, name, val)`**|`obj.x = val`|拦截所有的属性赋值操作。|**极易导致死循环**。必须使用 `super().__setattr__` 或 `self.__dict__` 来赋值。|
## 5.继承(Inheritance)
**目的**：避免重复造轮子，子类自动拥有父类的所有方法和属性。
- **语法**：`calss Child(Parent):`
- `super()`:调用父类的方法（通常用于初始化，如果直接在子类`init`，它会完全覆盖父类的`init`，导致父类的属性没有被创建）。

```python
# 父类：通用商品
class Item:
	def __init__(self, name, price)
		self.name = name
		self.price = price
		
	def info(self):
		prinnt(f"{self.name}:${self.price}")

# 子类：食品（继承自Item）
class Food(Item):
	def __init__(self, nmae, price, date):
		# 1.让父类把基础属性（name, price）处理好
		super().__init__(name, price)
		# 2.在处理自己特有的属性
		self.date = date
apple = Food("Apple", 2.5, "2025-12-01")
apple.info # 自动拥有父类的继承方法
```

---
# 9. 代码审美与工程规范 (Best Practices)

## 1. f-string 进阶格式化

Python 3.6+ 推出的高效字符串拼接方式。

- **精度控制**：`:.nf` (保留 n 位小数)。
    
- **宽度对齐**：`:n` (占 n 个字符宽)。
    

```python
pi = 3.1415926
print(f"保留两位: {pi:.2f}")  # 输出 3.14
print(f"宽度对齐: {pi:10.2f}") # 输出 "      3.14"
```

## 2. 占位符与特殊常量

### `pass` 语句

- **定义**：空语句，什么都不做。
    
- **作用**：保持代码结构完整。当你写了 `if` 或 `def` 但还没想好具体逻辑时，用 `pass` 占位，防止报 `IndentationError`。
    

### `None` 常量

- **定义**：表示“无”、“空”或“没有值”。
    
- **作用**：变量初始化。
    
- **判断**：必须使用 `is` 关键字。
    


```python
score = None
if score is None:
    print("暂无成绩")
```

## 3. PEP 8 代码规范

Python 官方推荐的代码风格指南 (Style Guide)。

|类别|规范要求|错误示例 (Bad)|正确示例 (Good)|
|---|---|---|---|
|**变量/函数名**|**蛇形命名 (snake_case)**|`UserScore`, `userscore`|`user_score`|
|**缩进**|强制 **4个空格**|Tab 混用空格|全空格|
|**运算符空格**|符号两边各留1空格|`a=b+1`|`a = b + 1`|
|**逗号习惯**|逗号后空格，前不空|`[1,2,3]`|`[1, 2, 3]`|
|**文档注释**|脚本/函数开头用三引号说明|`# 这是一个功能`|`""" 功能说明 """`|

## 4. 文档字符串 

- **单行注释**：`# 注释内容`。
    
- **多行/文档注释**：使用三引号 `""" 内容 """`，通常放在脚本开头或函数内部。

## 5. 程序保护入口（Entry Point）
- **代码**：`if __name__ == "__main__"`
- **作用**：

1. **直接运行脚本时**：缩进块内的代码**会执行**（通常用于启动主程序）。
    
2. **被其他脚本 Import 时**：缩进块内的代码**不会执行**（防止导入工具箱时自动运行了里面的逻辑）。
---
# 10.模块与包(Modules&Packages)
>当代码量变大时，我们需要将代码拆分到不同的文件中。
## 1. 基础导入(Import)
假设有一个工具文件`tools.py`，里面有一个`add()`函数。

| **写法**   | **说明**         | **示例**                  | **访问方式**      |
| -------- | -------------- | ----------------------- | ------------- |
| **全量导入** | 导入整个文件作为一个对象。  | `import tools`          | `tools.add()` |
| **精准导入** | 只导入需要的功能 (推荐)。 | `from tools import add` | `add()`       |
| **别名导入** | 名字太长或冲突时，起个外号。 | `import numpy as np`    | `np.array()`  |

## 2. 跨文件夹导入
假如项目结构如下:

```
Project/
├── main.py
└── core/
    ├── __init__.py  (标识这是一个包)
    └── handler.py   (里面有 save_data 函数)
```

在`main.py`中调用:
```python
from core.handler import save_data
```
`
	*tips* :`__init__.py` 在 Python 3.3 以前，文件夹里必须有这个文件（即使是空的）才会被视为一个包。现在的项目中通常依然保留它，用于标记目录结构。